PHP 5.5 引入了 `Generator`，`Generator` 通过封装之后，可以作为协程来进行使用。

Hprose 也提供了对 `Generator` 的一个封装，并且跟 `Promise` 相结合之后，可以实现异步代码同步化。

让我们来看一个例子：

```php
use \Hprose\Future;
use \Hprose\Http\Client;

Future\co(function() {
    $test = new Client("http://hprose.com/example/");
    var_dump((yield $test->hello("hprose")));
    $a = $test->sum(1, 2, 3);
    $b = $test->sum(4, 5, 6);
    $c = $test->sum(7, 8, 9);
    var_dump((yield $test->sum($a, $b, $c)));
    var_dump((yield $test->hello("world")));
});
```

`Future\co`（也可以用 `Promise\co`）就是一个协程封装函数。它的功能以协程的方式来执行生成器函数。该方法允许带入参数执行。

在上面的例子中，$test 是一个 Hprose 的异步 Http 客户端。Hprose 2.0 的默认客户端为异步客户端，而不是同步客户端，这一点与 1.x 不同。

所以 `$test->hello` 和 `$test->sum` 两个调用的返回值实际上是一个 `promise` 对象。而 `yield` 关键字在这里的作用就是，可以等待调用完成并返回 `promise` 所包含的值，如果 `promise` 的最后的状态为 `REJECTED`，那么 `yield` 将抛出一个异常，异常的值为 `promise` 对象中的 `reason` 属性值。

在上面的调用中，`$a`, `$b`, `$c` 三个变量都是 `promise` 对象，而 `$test->sum` 可以直接接受 `promise` 参数作为调用参数，当 `$a`, `$b`, `$c` 三个 `promise` 对象的状态都变为 `FULFILLED` 状态时，`$test-sum($a, $b, $c)` 才会真正的开始调用。而获取 `$a`,`$b`,`$c` 的三个调用是异步并发执行的。

上面程序的执行结果为：
>
```
string(12) "Hello hprose"
int(45)
string(11) "Hello world"
```
>

从结果我们可以看出，`co` 函数和 `yield` 的结合可以很方便的让异步程序编写同步化。这也是 Hprose 2.0 最有特色的改进之一。